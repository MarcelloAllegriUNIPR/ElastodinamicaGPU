module VuExtraSub_gpu_module
	contains

	attributes(device) FUNCTION curva_piu_meno_gpu(x_linea,tipo_allineamento,segno,vel) !!! per definire le rette dei domini in caso di elementi allineati (o eventualmete limiti delle ordinate)
		REAL(kind=8) :: curva_piu_meno_gpu, x_linea, vel
		INTEGER(kind=4) :: tipo_allineamento, segno
		select case (tipo_allineamento)
		   case (1)!!!!!allineati
			curva_piu_meno_gpu=CBCCCECF_d*x_linea+CACCCFCD_d+sign(1,segno)*vel*delta_x_d
		   case (2)!!!!!paralleli
			curva_piu_meno_gpu=CBCCCECF_d*x_linea+CACCCFCD_d+sign(1,segno)*sqrt(dabs((vel*delta_x_d)**2-(CFCACCCD_d)**2))
		   case (3)!!!!!generici
			curva_piu_meno_gpu=CBCCCECF_d*x_linea+CACCCFCD_d+sign(1,segno)*sqrt(dabs(-(CBCFCECC_d*x_linea)**2+2*CBCFCECC_d*(-CFCACCCD_d)*x_linea-(CFCACCCD_d)**2+vel**2*delta_x_d**2))
		end select
	END FUNCTION curva_piu_meno_gpu
	
	 attributes(global) subroutine CalculateP2a(B1,A1,xtrasl, wint, ds, serv, fiUServ, alfa_j1, w, fiUXtrasl, CA, CB, CC, CE, CF, CD, coeff_delta_kronecker, delta_x, cs,cp,indice_i,indice_j,p2,p2a,delta_kronecker)    
		use cudafor
		implicit none
		real(kind=8),dimension(:) :: xtrasl, wint, ds, alfa_j1, w, fiUXtrasl, B1, A1
		real(kind=8),dimension(:,:) :: serv, fiUServ, p2
		real(kind=8),dimension(:),intent(inout) :: p2a
		real(kind=8) :: CA, CB, CC, CE, CF, CD, r2_1, coeff_delta_kronecker, delta_x, cs, cp
		REAL(kind=8), DIMENSION(2) :: r
		INTEGER(kind=4), DIMENSION(2,2) :: delta_kronecker
		integer(kind=4) :: indice_i, indice_j
		integer(kind=4) :: x, y, istat	
	
		x = threadIdx%x
    	y = threadIdx%y	
		p2(x,y) = 0.d0	
	
		IF (B1(x)-A1(x).gt.10.d-14) THEN		
		r2_1=(CA+CB*xtrasl(x)-CC*serv(x,y))**2+(CD+CE*xtrasl(x)-CF*serv(x,y))**2
		r(1)=CA+CB*xtrasl(x)-CC*serv(x,y)
		r(2)=CD+CE*xtrasl(x)-CF*serv(x,y)
		!p2(x,y) = -wint(y)*ds(y)* fiUServ(x,y) *(r(indice_i)*r(indice_j)/(r2_1**2)-coeff_delta_kronecker/r2_1)*(delta_x/cs)*sqrt(dabs((cs*delta_x)**2-r2_1))		

		!IF (delta_kronecker(indice_i,indice_j).eq.1.d0) THEN
		!	p2(x,y)= p2(x,y)+wint(y)*ds(y)*fiUServ(x,y)*coeff_delta_kronecker*(1/cs**2)*(dlog(cs*delta_x+sqrt(dabs((cs*delta_x)**2-r2_1)))-dlog(sqrt(r2_1)))
		!ENDIF

		p2(x,y) = +wint(y)*ds(y)* fiUServ(x,y) *(r(indice_i)*r(indice_j)/(r2_1**2)-coeff_delta_kronecker/r2_1)*(delta_x/cp)*sqrt(dabs((cp*delta_x)**2-r2_1))		

		IF (delta_kronecker(indice_i,indice_j).eq.1.d0) THEN
			p2(x,y)= p2(x,y)+wint(y)*ds(y)*fiUServ(x,y)*coeff_delta_kronecker*(1/cs**2)*(dlog(cs*delta_x+sqrt(dabs((cs*delta_x)**2-r2_1)))-dlog(sqrt(r2_1)))
		ENDIF

		call syncthreads()
		if (y.le.16) then 
			p2(x,y) = p2(x,y) + p2(x,y+16) 
		endif
		call syncthreads()
		if (y.le.8) then 
			p2(x,y) = p2(x,y) + p2(x,y+8) 
		endif
		call syncthreads()
        if (y.le.4) then 
			p2(x,y) = p2(x,y) + p2(x,y+4) 
		endif
		call syncthreads()
        if (y.le.2) then 
			p2(x,y) = p2(x,y) + p2(x,y+2) 
		endif
		call syncthreads()
        if (y.eq.1) then 
			p2a(x) = p2(x,y) + p2(x,y+1)
			!p2(x,y) = p2(x,y) * alfa_j1(x) * fiUXtrasl(x) * w(x)
		endif
		call syncthreads()
		ENDIF	
		return
		
	end subroutine CalculateP2a

	attributes(global) subroutine Sum(p2a,alfa_j1,fiUXtrasl,w,p2_d)

		real(kind=8),dimension(:) :: alfa_j1, w, fiUXtrasl,p2a
		real(kind=8),intent(inout) :: p2_d
		integer(kind=4) :: x

		x = threadIdx%x
		p2a(x) = p2a(x) * alfa_j1(x) * fiUXtrasl(x) * w(x)

		if (x.le.16) then 
		p2a(x) = p2a(x) + p2a(x+16)
		endif
		call syncthreads()
		if (x.le.8) then 
		p2a(x) = p2a(x) + p2a(x+8) 
		endif
		call syncthreads()
		if (x.le.4) then 
		p2a(x) = p2a(x) + p2a(x+4) 
		endif
		call syncthreads()
		if (x.le.2) then 
		p2a(x) = p2a(x) + p2a(x+2) 
		endif
		call syncthreads()
		if (x.eq.1) then 
		p2a(x) = p2a(x) + p2a(x+1)
		p2_d = p2a(1)			
		endif
		return
	end subroutine Sum
end module VuExtraSub_gpu_module

module VuExtraGpu

	use cudafor
	implicit none
	
	integer, device :: Ngauss_d = 32
	real(kind=8),dimension(:),allocatable,device :: wint_d, xint_d, w_d, x_d, p2_d
	real(kind=8), device :: CA_d, CB_d, CC_d, CE_d, CF_d, CD_d, &
							coeff_delta_kronecker_d, delta_x_d, cs_d,cp_d, &
							estremo_m_d, estremo_m_tilde_d, CBCFCECC_d, CFCACCCD_d, &
							CBCCCECF_d, CACCCFCD_d, CACBCDCE_d, CBCDCECA_d
							
	integer(kind=4), dimension(2,2), device :: delta_kronecker_d
	integer(kind=4), device :: indice_i_d, indice_j_d, dimX_d, dimY_d, flag_extra_d,&
							   grado_q_d, l_m_tilde_d,l_m_d   
	contains

	attributes(host) subroutine setCommonData(wint, w, xint, x, cp, cs, grado_q)

        integer :: istat, AllocateStatus   
        integer, intent(in) :: grado_q
        double precision, intent(in) :: cs, cp	
        double precision, dimension(:), intent(in) :: wint, w, xint, x


        ALLOCATE(x_d(Ngauss_d),STAT=AllocateStatus)
        IF (AllocateStatus /= 0) STOP "*** Not enough memory ***"
        ALLOCATE(w_d(Ngauss_d),STAT=AllocateStatus)
        IF (AllocateStatus /= 0) STOP "*** Not enough memory ***"
        ALLOCATE(xint_d(Ngauss_d),STAT=AllocateStatus)
        IF (AllocateStatus /= 0) STOP "*** Not enough memory ***"
        ALLOCATE(wint_d(Ngauss_d),STAT=AllocateStatus)
        IF (AllocateStatus /= 0) STOP "*** Not enough memory ***"
		ALLOCATE(p2_d(Ngauss_d),STAT=AllocateStatus)
        IF (AllocateStatus /= 0) STOP "*** Not enough memory ***"        

		!inizializzabili 1 sola volta
		wint_d = wint
		w_d = w
		x_d = x
		xint_d = xint	
		grado_q_d = grado_q_d
		delta_kronecker_d(1,1) = 1
        delta_kronecker_d(1,2) = 0
        delta_kronecker_d(2,1) = 0
        delta_kronecker_d(2,2) = 1
		cp_d = cp
        cs_d = cs		

		!print *, "copia effettuata"
	end subroutine setCommonData
	
	attributes(host) subroutine setInstanceCommonData(delta_x, indice_i, indice_j, &
	CA, CB, CC, CD, CE, CF, coeff_delta_kronecker, flag_extra, estremo_m, &
	l_m_tilde,l_m,estremo_m_tilde, CBCFCECC, CFCACCCD, CBCCCECF, CACCCFCD, &
	CACBCDCE, CBCDCECA)

		double precision, intent(in) :: CA, CB, CC, CE, CF, CD, coeff_delta_kronecker, &
									 delta_x, estremo_m, estremo_m_tilde, &
									 CBCFCECC, CFCACCCD, CBCCCECF, CACCCFCD, CACBCDCE, CBCDCECA	
		integer, intent(in) :: indice_j, indice_i, flag_extra, l_m_tilde, l_m

		!cambiano ad ogni chiamata di vuextraSub
		delta_x_d = delta_x
			
		indice_i_d = indice_i
		indice_j_d = indice_j
		CA_d = CA
		CB_d = CB
		CC_d = CC
		CD_d = CD
		CE_d = CE
		CF_d = CF
		coeff_delta_kronecker_d = coeff_delta_kronecker        
		flag_extra_d = flag_extra
		l_m_tilde_d = l_m_tilde
		l_m_d = l_m
		estremo_m_d = estremo_m
		estremo_m_tilde_d = estremo_m_tilde
		

		CBCFCECC_d = CBCFCECC
		CFCACCCD_d = CFCACCCD
		CBCCCECF_d = CBCCCECF 
		CACCCFCD_d = CACCCFCD
		CACBCDCE_d = CACBCDCE
		CBCDCECA_d = CBCDCECA

	end subroutine setInstanceCommonData

	attributes(host) subroutine garbageCollector
		deallocate(x_d)
		deallocate(xint_d)
		deallocate(w_d)
		deallocate(p2_d)        
	end subroutine

	attributes(global) subroutine performCalcEP(alfa_d, beta_d, iplog_d, iqlog_d) !,p2a)

		use Gauss_Gpu
		
		integer :: ki,kj,app,k,i
		integer, intent(in) :: iplog_d, iqlog_d!, blockNumber
		double precision :: xtrasl, A1, B1, alfa_j1, beta_j1, xinttrasl, s, ds, serv, r2_1, r(2)
		double precision, shared :: p2a(*) 
		double precision, intent(in) :: alfa_d, beta_d

		ki = blockidx%x
		p2_d(ki) = 0.d0
		kj = threadIdx%y

		xtrasl=alfa_d*x_d(ki)+beta_d
		A1=dmax1(0.d0,curva_piu_meno_gpu(xtrasl,flag_extra_d,-1,cp_d))
	   	B1=dmin1(estremo_m_d,curva_piu_meno_gpu(xtrasl,flag_extra_d,1,cp_d))
		alfa_j1=(B1-A1)/2.d0
		beta_j1=(B1+A1)/2.d0
		p2a(kj) = 0.d0				 
		!IF ((B1-A1).gt.10.d-15) THEN
		IF ((B1-A1).gt.10.d-14) THEN			
				xinttrasl=(xint_d(kj)+1.d0)*0.5d0
				s=fi1_d(iplog_d,iqlog_d,xinttrasl)
				ds=dfi1_d(iplog_d,iqlog_d,xinttrasl)
				serv=alfa_j1*(2.d0*s-1.d0)+beta_j1
				r2_1=(CA_d+CB_d*xtrasl-CC_d*serv)**2+(CD_d+CE_d*xtrasl-CF_d*serv)**2
				r(1)=CA_d+CB_d*xtrasl-CC_d*serv
				r(2)=CD_d+CE_d*xtrasl-CF_d*serv
				p2a(kj) = +wint_d(kj)*ds*fiU_gpu(l_m_d,serv,estremo_m_d,grado_q_d)*(r(indice_i_d)*r(indice_j_d)/(r2_1**2)-coeff_delta_kronecker_d/r2_1)*(delta_x_d/cp_d)*sqrt(dabs((cp_d*delta_x_d)**2-r2_1))
				
				!if(ki .eq. 16) then
				!	print *,"gpu",kj, wint_d(kj)
				!endif
				
				!!p2a = p2a + wint(kj)*ds*fiU(l_m,serv,estremo_m,grado_q)*(r(indice_i)*r(indice_j)/(r2_1**2)-coeff_delta_kronecker/r2_1)*(delta_x/cp)*sqrt((cp*delta_x)**2-r2_1)
				IF (delta_kronecker_d(indice_i_d,indice_j_d).eq.1.d0) THEN	                        
				   p2a(kj)= p2a(kj)+wint_d(kj)*ds*fiU_gpu(l_m_d,serv,estremo_m_d,grado_q_d)*coeff_delta_kronecker_d*(1/cp_d**2)*(dlog(cp_d*delta_x_d+sqrt(dabs((cp_d*delta_x_d)**2-r2_1)))-dlog(sqrt(r2_1)))	                         
				ENDIF	
				
				
				!if(ki .eq. 16) then
				!	print *,"p2a value gpu",kj, p2a(kj)
				!endif

				call syncthreads()

				!if(kj .eq. 1 .and. blockNumber .eq.1) then 
				!	print *, "prima somma"
				!endif				
				if(kj.le.16) then					
					!if(ki .eq. 16) then 
					!	print *,kj, p2a(kj),p2a(kj+16), p2a(kj)+p2a(kj+16)
					!endif

					p2a(kj) = p2a(kj)+p2a(kj+16)
				endif
				
				call syncthreads()

				if(kj .le. 8) then
					p2a(kj) = p2a(kj)+p2a(kj+8)					
				endif

				call syncthreads()

				if(kj .le. 4) then
					p2a(kj) = p2a(kj)+p2a(kj+4)					
				endif

				call syncthreads()

				if(kj .le. 2) then
					p2a(kj) = p2a(kj)+p2a(kj+2)
				endif

				call syncthreads()

				if(kj .eq. 1) then 
					p2a(kj) = p2a(kj)+p2a(kj+1)
					!if(ki .eq. 16) then
					!	print *,"reduction gpu", ki, p2a(kj)
					!endif
					!print *, blockNumber, p2a(1)
					p2_d(ki) = p2a(1)*alfa_j1*w_d(ki)*fiU_gpu(l_m_tilde_d,xtrasl,estremo_m_tilde_d,grado_q_d)					
					!print *,"sum gpu: ", ki, p2a(1)
				endif
		ENDIF		
		
		!if(kj .eq. 1) then 
		!	p2_d(blockNumber) = p2a(1)*alfa_j1*w_d(ki)*fiU_gpu(l_m_tilde_d,xtrasl,estremo_m_tilde_d,grado_q_d)		
			
		!	if(blockNumber .eq. 1) then
		!		print *, "somma: ",kj, p2a(1)
		!	endif
			!	print *,"p2 gpu: ", blockNumber,p2_d(blockNumber)
		!endif
	end subroutine

	attributes(global) subroutine performCalcES(alfa_d, beta_d, iplog_d, iqlog_d) !,p2a)

		use Gauss_Gpu
		
		integer :: ki,kj,app,k,i
		integer, intent(in) :: iplog_d, iqlog_d!, blockNumber
		double precision :: xtrasl, A1, B1, alfa_j1, beta_j1, xinttrasl, s, ds, serv, r2_1, r(2)
		double precision, shared :: p2a(*) 
		double precision, intent(in) :: alfa_d, beta_d

		ki = blockidx%x
		p2_d(ki) = 0.d0
		kj = threadIdx%y

		xtrasl=alfa_d*x_d(ki)+beta_d
		A1=dmax1(0.d0,curva_piu_meno_gpu(xtrasl,flag_extra_d,-1,cs_d))
	   	B1=dmin1(estremo_m_d,curva_piu_meno_gpu(xtrasl,flag_extra_d,1,cs_d))
		alfa_j1=(B1-A1)/2.d0
		beta_j1=(B1+A1)/2.d0
		p2a(kj) = 0.d0				 
		!IF ((B1-A1).gt.10.d-15) THEN
		IF ((B1-A1).gt.10.d-14) THEN			
				xinttrasl=(xint_d(kj)+1.d0)*0.5d0
				s=fi1_d(iplog_d,iqlog_d,xinttrasl)
				ds=dfi1_d(iplog_d,iqlog_d,xinttrasl)
				serv=alfa_j1*(2.d0*s-1.d0)+beta_j1
				r2_1=(CA_d+CB_d*xtrasl-CC_d*serv)**2+(CD_d+CE_d*xtrasl-CF_d*serv)**2
				r(1)=CA_d+CB_d*xtrasl-CC_d*serv
				r(2)=CD_d+CE_d*xtrasl-CF_d*serv
				p2a(kj) = -wint_d(kj)*ds*fiU_gpu(l_m_d,serv,estremo_m_d,grado_q_d)*(r(indice_i_d)*r(indice_j_d)/(r2_1**2)-coeff_delta_kronecker_d/r2_1)*(delta_x_d/cs_d)*sqrt(dabs((cs_d*delta_x_d)**2-r2_1))
				
				IF (delta_kronecker_d(indice_i_d,indice_j_d).eq.1.d0) THEN	                        
				   p2a(kj)= p2a(kj)+wint_d(kj)*ds*fiU_gpu(l_m_d,serv,estremo_m_d,grado_q_d)*coeff_delta_kronecker_d*(1/cs_d**2)*(dlog(cs_d*delta_x_d+sqrt(dabs((cs_d*delta_x_d)**2-r2_1)))-dlog(sqrt(r2_1)))	                         
				ENDIF	
				
				call syncwarp(ki)
				
				if(kj.le.16) then
					p2a(kj) = p2a(kj)+p2a(kj+16)
				endif
				
				call syncwarp(ki)

				if(kj .le. 8) then
					p2a(kj) = p2a(kj)+p2a(kj+8)					
				endif

				call syncwarp(ki)

				if(kj .le. 4) then
					p2a(kj) = p2a(kj)+p2a(kj+4)					
				endif

				call syncwarp(ki)

				if(kj .le. 2) then
					p2a(kj) = p2a(kj)+p2a(kj+2)
				endif

				call syncwarp(ki)

				if(kj .eq. 1) then 
					p2a(kj) = p2a(kj)+p2a(kj+1)					
					p2_d(ki) = p2a(1)*alfa_j1*w_d(ki)*fiU_gpu(l_m_tilde_d,xtrasl,estremo_m_tilde_d,grado_q_d)					
					!print *, "gpu", ki, p2_d(ki)
				endif
		ENDIF		
	end subroutine

	attributes(global) subroutine finalSum(finalp2)

		double precision,device, intent(inout) :: finalp2
		integer :: app,k,i

		!if(threadIdx%x .eq. 1) then 
		!	print *, "- - - - - - - - - - - - - - - - - - -"
		!endif
		!print *, "gpu p2:",threadIdx%x, p2_d(threadIdx%x)
		call syncthreads()

		if(threadIdx%x .le. 16) then
			p2_d(threadIdx%x) = p2_d(threadIdx%x)+p2_d(threadIdx%x+16)			
		endif

		call syncwarp(blockidx%x)

		if(threadIdx%x .le. 8) then
			p2_d(threadIdx%x) = p2_d(threadIdx%x)+p2_d(threadIdx%x+8)			
		endif

		call syncwarp(blockidx%x)

		if(threadIdx%x .le. 4) then
			p2_d(threadIdx%x) = p2_d(threadIdx%x)+p2_d(threadIdx%x+4)			
		endif

		call syncwarp(blockidx%x)

		if(threadIdx%x .le. 2) then
			p2_d(threadIdx%x) = p2_d(threadIdx%x)+p2_d(threadIdx%x+2)			
		endif

		call syncwarp(blockidx%x)

		if(threadIdx%x .eq. 1) then 
			p2_d(threadIdx%x) = p2_d(threadIdx%x)+p2_d(threadIdx%x+1)			
			finalp2 = p2_d(1)
			!print *,"gpu",p2_d(1)
		endif		
	end subroutine finalSum

	attributes(device) FUNCTION curva_piu_meno_gpu(x_linea,tipo_allineamento,segno,vel) !!! per definire le rette dei domini in caso di elementi allineati (o eventualmete limiti delle ordinate)
		REAL(kind=8) :: curva_piu_meno_gpu, x_linea, vel
		INTEGER(kind=4) :: tipo_allineamento, segno
		select case (tipo_allineamento)
		   case (1)!!!!!allineati
			curva_piu_meno_gpu=CBCCCECF_d*x_linea+CACCCFCD_d+sign(1,segno)*vel*delta_x_d
		   case (2)!!!!!paralleli
			curva_piu_meno_gpu=CBCCCECF_d*x_linea+CACCCFCD_d+sign(1,segno)*sqrt(dabs((vel*delta_x_d)**2-(CFCACCCD_d)**2))
		   case (3)!!!!!generici
			curva_piu_meno_gpu=CBCCCECF_d*x_linea+CACCCFCD_d+sign(1,segno)*sqrt(dabs(-(CBCFCECC_d*x_linea)**2+2*CBCFCECC_d*(-CFCACCCD_d)*x_linea-(CFCACCCD_d)**2+vel**2*delta_x_d**2))
		end select
	END FUNCTION curva_piu_meno_gpu

	attributes(device) Double precision function fiU_gpu(l,x,lung,grado_q)
		IMPLICIT NONE	 
	   
	    INTEGER(kind=4),INTENT(IN):: l, grado_q
	    REAL(kind=8),INTENT(IN):: x, lung

	   	if ((l.lt.1).or.(l.gt.(grado_q+1))) then
			write (*,*) 'Errore di indice nella funzione di forma di gammau'
		else
			fiU_gpu=plagran_gpu(grado_q,l-1,x/(lung/2.d0)-1.d0)
		endif
	 
	   RETURN
	END

	attributes(device) Double precision function plagran_gpu(igrado,j,x)   
    	!Funzione che valuta il polinomio j-esimo interpolatore di Lagrange di grado igrado, su una decomposizione uniforme 
		!dell'intervallo, nel punto x
	    integer, intent(in) :: igrado,j
		integer :: pnum, den, k
		double precision, intent(in) :: x
		double precision pj
		
		pj=1.d0
		if (igrado.gt.0) then
			DO k=0,igrado
				if (k.ne.j) then
					pnum=igrado*(x+1)-2*k
					den=2*(j-k)
					pj=pj*pnum/den
				endif
			END DO
		endif
		plagran_gpu=pj
		RETURN
	END

	attributes(device) double precision function dfi1_d(ip,iq,t)
		
		double precision, intent(in) :: t
		integer, intent(in) :: ip,iq
		
		integer :: i, cn, cd
		double precision coef
		cn=ip
		cd=1.d0
		do 15 i=1,iq-1
		cd=cd*i
		cn=cn*(ip+i)
		15      continue
		coef=cn/cd
		dfi1_d=coef*t**(ip-1)*(1.d0-t)**(iq-1)
	return
	end
end module VuExtraGpu