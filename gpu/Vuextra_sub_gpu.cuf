attributes(host) subroutine Vuextra_sub_gpu(l_m_tilde,l_m,e_m_tilde,e_m,tempo1,tempo2,indice_i,indice_j,CalculationResults,rowIndex)

  USE variable_2Dgeneral
  use cudafor
  use OMP_LIB
  use VuExtraGpu
  IMPLICIT NONE

  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! VARIABILI !!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  Double precision, intent(out), device :: CalculationResults(10,4)  
  integer, intent(in) :: rowIndex
  !Input
  INTEGER(kind=4),INTENT(IN):: e_m_tilde, e_m, l_m_tilde, l_m, indice_i, indice_j
  REAL(kind=8),INTENT(IN):: tempo1, tempo2
  
  REAL(kind=8) :: delta_x, alfa, beta, cs, cp, app
  !Variabili locali
  INTEGER(kind=4) :: AllocateStatus, iplog, iqlog
  INTEGER(kind=4):: flag_extra, ii, jj,ierrSync
  REAL(kind=8):: estremo_m, estremo_m_tilde, &
                 coeff_delta_kronecker, CA, CB, CC, CE, CF, CD, &
				 CBCFCECC, CFCACCCD, CBCCCECF, CACCCFCD, CACBCDCE, CBCDCECA, deltaquartiS, deltaquartiP, &
				 Vuextra_sub_P, Vuextra_sub_S, deltaquartiS_bis, deltaquartiP_bis, deltaquartiS_bbis, deltaquartiP_bbis, radice_incriminata
  INTEGER(kind=4), DIMENSION(2,2) :: delta_kronecker
  REAL(kind=8), DIMENSION(6) :: xx
  REAL(kind=8),DIMENSION(:),ALLOCATABLE :: x
  REAL(kind=8), DIMENSION(2) :: r, punto_m_1, punto_m_2, punto_m_tilde_1, punto_m_tilde_2

  DOUBLE PRECISION START1, END
  

  integer :: istat, ind_gauss = 6
  type(cudaEvent) :: start, stop  
  real :: time
  double precision, device :: alfa_d, beta_d !CalculationResults(10),
  integer, device :: iplog_d, iqlog_d
  !!!!!!!!!!!!!!!!!!!!!!!!!! CORPO della SUBROUTINE !!!!!!!!!!!!!!!!!!
  istat = cudaEventCreate(start)
  istat = cudaEventCreate(stop)
  
  cs=velC_S
  cp=velC_P
  
  punto_m_1=list_nodes(e_m)%coordinates(1:2)
  punto_m_2=list_nodes(e_m+1)%coordinates(1:2)
  punto_m_tilde_1=list_nodes(e_m_tilde)%coordinates(1:2)
  punto_m_tilde_2=list_nodes(e_m_tilde+1)%coordinates(1:2)
  
  delta_kronecker(1,1)=1
  delta_kronecker(1,2)=0
  delta_kronecker(2,1)=0
  delta_kronecker(2,2)=1
  coeff_delta_kronecker=delta_kronecker(indice_i,indice_j)/2.d0
  

delta_x=tempo1-tempo2
IF (delta_x.le.0.d0) RETURN

  estremo_m=sqrt((punto_m_2(1)-punto_m_1(1))**2+(punto_m_2(2)-punto_m_1(2))**2)
  estremo_m_tilde=sqrt((punto_m_tilde_2(1)-punto_m_tilde_1(1))**2+(punto_m_tilde_2(2)-punto_m_tilde_1(2))**2)
  
  CA=punto_m_tilde_1(1)-punto_m_1(1)
  CB=(punto_m_tilde_2(1)-punto_m_tilde_1(1))/estremo_m_tilde
  CC=(punto_m_2(1)-punto_m_1(1))/estremo_m
  CD=punto_m_tilde_1(2)-punto_m_1(2)
  CE=(punto_m_tilde_2(2)-punto_m_tilde_1(2))/estremo_m_tilde
  CF=(punto_m_2(2)-punto_m_1(2))/estremo_m

  CBCFCECC=CB*CF-CE*CC
  CFCACCCD=CF*CA-CC*CD
  CBCDCECA=CB*CD-CE*CA
  CBCCCECF=CB*CC+CE*CF
  CACCCFCD=CA*CC+CF*CD
  CACBCDCE=CA*CB+CD*CE 

  deltaquartiS=(cs*delta_x)**2-CFCACCCD**2
  deltaquartiP=(cp*delta_x)**2-CFCACCCD**2
  
  deltaquartiS_bis=(cs*delta_x)**2-CBCDCECA**2
  deltaquartiP_bis=(cp*delta_x)**2-CBCDCECA**2
  
  deltaquartiS_bbis=-(CBCDCECA)**2-estremo_m**2*(CBCFCECC)**2+2*estremo_m*CBCDCECA*CBCFCECC+(cs*delta_x)**2
  deltaquartiP_bbis=-(CBCDCECA)**2-estremo_m**2*(CBCFCECC)**2+2*estremo_m*CBCDCECA*CBCFCECC+(cp*delta_x)**2
     
  if((dabs(CBCFCECC).le.1.d-15).and.(dabs(CFCACCCD).le.1.d-15)) then
     flag_extra=1    !	elementi extra ma allineati
  elseif((dabs(CBCFCECC).le.1.d-15).and.(dabs(CFCACCCD).gt.1.d-15)) then
     flag_extra=2    !	paralleli 
  else
     flag_extra=3    !   non allineati non paralleli
  endif

  ALLOCATE(x(2**(ind_gauss-1)),STAT=AllocateStatus)
  IF (AllocateStatus /= 0) STOP "*** Not enough memory ***"
  
  x=gauss(ind_gauss)%nodiquad

!   print *,"rowIndex",rowIndex
    call setInstanceCommonData(delta_x, indice_i, indice_j, CA, CB, CC, CD, CE, CF, &
                     coeff_delta_kronecker, flag_extra, estremo_m, l_m_tilde,l_m, estremo_m_tilde, &
                     CBCFCECC, CFCACCCD, CBCCCECF, CACCCFCD, CACBCDCE, CBCDCECA)
  !*************************************
  !             INTEGRAZIONE SU ES
  !*************************************


  IF((CBCFCECC.eq.0.d0).and.(deltaquartiS.lt.0.d0))then
     Vuextra_sub_S=0.d0
  else
     select case(flag_extra)
         case(1) 
	         if(CBCCCECF.lt.0.d0)then
                 xx(1)=-CACBCDCE+estremo_m*(CBCCCECF)-cs*delta_x
                 xx(4)=-CACBCDCE+cs*delta_x
                 xx(2)=dmin1(-CACBCDCE+estremo_m*(CBCCCECF)+cs*delta_x,-CACBCDCE-cs*delta_x)
		         xx(3)=dmax1(-CACBCDCE+estremo_m*(CBCCCECF)+cs*delta_x,-CACBCDCE-cs*delta_x)
			     xx(5)=xx(4)
			     xx(6)=xx(4)
		     else
		 	     xx(1)=-CACBCDCE-cs*delta_x
                 xx(4)=-CACBCDCE+estremo_m*(CBCCCECF)+cs*delta_x
                 xx(2)=dmin1(-CACBCDCE+estremo_m*(CBCCCECF)-cs*delta_x,-CACBCDCE+cs*delta_x)
		         xx(3)=dmax1(-CACBCDCE+estremo_m*(CBCCCECF)-cs*delta_x,-CACBCDCE+cs*delta_x)       
			     xx(5)=xx(4)
			     xx(6)=xx(4)
             endif
	     case(2)
		     if(CBCCCECF.lt.0.d0)then
                 xx(1)=-CACBCDCE+estremo_m*(CBCCCECF)-sqrt(deltaquartiS_bis)
                 xx(4)=-CACBCDCE+sqrt(deltaquartiS_bis)
				 xx(2)=dmin1(-CACBCDCE+estremo_m*(CBCCCECF)+sqrt(deltaquartiS_bis),-CACBCDCE-sqrt(deltaquartiS_bis))
				 xx(3)=dmax1(-CACBCDCE+estremo_m*(CBCCCECF)+sqrt(deltaquartiS_bis),-CACBCDCE-sqrt(deltaquartiS_bis))
				 xx(5)=xx(4)
				 xx(6)=xx(4)
			 else
                 xx(1)=-CACBCDCE-sqrt(deltaquartiS_bis)
	             xx(4)=-CACBCDCE+estremo_m*(CBCCCECF)+sqrt(deltaquartiS_bis)
				 xx(2)=dmin1(-CACBCDCE+estremo_m*(CBCCCECF)-sqrt(deltaquartiS_bis),-CACBCDCE+sqrt(deltaquartiS_bis))
				 xx(3)=dmax1(-CACBCDCE+estremo_m*(CBCCCECF)-sqrt(deltaquartiS_bis),-CACBCDCE+sqrt(deltaquartiS_bis))
				 xx(5)=xx(4)
				 xx(6)=xx(4)				 
             endif
         case(3)
		     xx(1)=dmin1((CFCACCCD-cs*delta_x)/(-CBCFCECC),(CFCACCCD+cs*delta_x)/(-CBCFCECC))
			 xx(6)=dmax1((CFCACCCD-cs*delta_x)/(-CBCFCECC),(CFCACCCD+cs*delta_x)/(-CBCFCECC))
			 if(deltaquartiS_bis.ge.0.d0)then
			     xx(2)=-(CACBCDCE)-sqrt(deltaquartiS_bis)
				 xx(3)=-(CACBCDCE)+sqrt(deltaquartiS_bis)
		     else		 
		     	 xx(2)=xx(1)
				 xx(3)=xx(1)
			 endif
			 if(deltaquartiS_bbis.ge.0.d0)then
			     xx(4)=-(CACBCDCE)+estremo_m*CBCCCECF-sqrt(deltaquartiS_bbis)
				 xx(5)=-(CACBCDCE)+estremo_m*CBCCCECF+sqrt(deltaquartiS_bbis)
		     else		 
		     	 xx(4)=xx(6)
				 xx(5)=xx(6)
			 endif
			 DO ii=2,6 !!!!!!!!!!!!!!!!ordinamento dei punti con insertion sort
                 app=xx(ii)       
                 jj=ii-1
                 do while (jj.ge.1)
                     if (xx(jj).gt.app) then
                         xx(jj+1)=xx(jj)
                         jj=jj-1 
                         xx(jj+1)=app
                     else 
                         exit
                     endif
	             enddo
             ENDDO
	 end select
	 do ii=1,6!!!!!!!!!!!!!!!!!taglio fuori i punti  minori di zero e maggiori di estremo_m_tilde
	     if(xx(ii).lt.0.d0)then
		     xx(ii)=0.d0
		 endif
         if(xx(ii).gt.estremo_m_tilde)then
		     xx(ii)=estremo_m_tilde
		 endif
	 enddo
   
        DO ii=1,5!!!!!!!!!!!!!!!!!!!!!!!!integrazione nucleo su ES!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!            
            if(xx(ii+1)-xx(ii).gt.1.d-14)then		 
                alfa_d=(xx(ii+1)-xx(ii))/2.d0
                beta_d=(xx(ii+1)+xx(ii))/2.d0

                !print *, "b"
                iplog_d=1
                iqlog_d=1
                if(curva_piu_meno(beta,flag_extra,1,cs).le.estremo_m)then
                    iqlog_d=2
                elseif((curva_piu_meno(x(ii),flag_extra,1,cs).eq.estremo_m).or.(curva_piu_meno(x(ii+1),flag_extra,1,cs).eq.estremo_m))then
                    iqlog_d=2         
                endif			

                if(curva_piu_meno(beta,flag_extra,-1,cs).ge.0.d0)then
                    iplog_d=2
                elseif((curva_piu_meno(x(ii),flag_extra,-1,cs).eq.0.d0).or.(curva_piu_meno(x(ii+1),flag_extra,-1,cs).eq.0.d0))then
                    iplog_d=2
                endif
                
                istat = cudaEventRecord(start,0)
                
                
                call preCalculationES<<<dimGrid,dimBlockPreCalculation>>>(alfa_d,beta_d,iplog_d, iqlog_d)                
                call performCalcES<<<dimGrid,dimBlockCalculation,sizeof(app)*NGaussDimension*NGaussDimension>>>(alfa_d,CalculationResults(ii,rowIndex))                
                !app = CalculationResults(ii,rowIndex)
                !print *,app
                !pause
                !  istat = cudaEventRecord(stop,0)
                !  istat = cudaEventSynchronize ( stop )
                !  istat = cudaEventElapsedTime(time, start, stop)                
                !  gputime = gputime + time/(1.0e3)

                !  ierrSync = cudaGetLastError()
                !  if (ierrSync /= cudaSuccess) then
                !      write(*,*) 'Sync kernel error:', cudaGetErrorString(ierrSync)
                !     pause
                !  endif
            endif
        enddo  
   
  endif
  
  ! write(*,*) 'integrale cs', Vuextra_sub_S!!!!!!!!!!!!!!!!!
  ! pause!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  
  
  !*************************************
  !             INTEGRAZIONE SU EP
  !*************************************
  IF((CBCFCECC.eq.0.d0).and.(deltaquartiP.lt.0.d0))then
     Vuextra_sub_P=0.d0
  else
     select case(flag_extra)
         case(1) 
	         if(CBCCCECF.lt.0.d0)then
                 xx(1)=-CACBCDCE+estremo_m*(CBCCCECF)-cp*delta_x
                 xx(4)=-CACBCDCE+cp*delta_x
                 xx(2)=dmin1(-CACBCDCE+estremo_m*(CBCCCECF)+cp*delta_x,-CACBCDCE-cp*delta_x)
		         xx(3)=dmax1(-CACBCDCE+estremo_m*(CBCCCECF)+cp*delta_x,-CACBCDCE-cp*delta_x)
			     xx(5)=xx(4)
			     xx(6)=xx(4)
		     else
		 	     xx(1)=-CACBCDCE-cp*delta_x
                 xx(4)=-CACBCDCE+estremo_m*(CBCCCECF)+cp*delta_x
                 xx(2)=dmin1(-CACBCDCE+estremo_m*(CBCCCECF)-cp*delta_x,-CACBCDCE+cp*delta_x)
		         xx(3)=dmax1(-CACBCDCE+estremo_m*(CBCCCECF)-cp*delta_x,-CACBCDCE+cp*delta_x)       
			     xx(5)=xx(4)
			     xx(6)=xx(4)
             endif
	     case(2)
		     if(CBCCCECF.lt.0.d0)then
                 xx(1)=-CACBCDCE+estremo_m*(CBCCCECF)-sqrt(deltaquartiP_bis)
                 xx(4)=-CACBCDCE+sqrt(deltaquartiP_bis)
				 xx(2)=dmin1(-CACBCDCE+estremo_m*(CBCCCECF)+sqrt(deltaquartiP_bis),-CACBCDCE-sqrt(deltaquartiP_bis))
				 xx(3)=dmax1(-CACBCDCE+estremo_m*(CBCCCECF)+sqrt(deltaquartiP_bis),-CACBCDCE-sqrt(deltaquartiP_bis))
				 xx(5)=xx(4)
				 xx(6)=xx(4)
			 else
                 xx(1)=-CACBCDCE-sqrt(deltaquartiP_bis)
	             xx(4)=-CACBCDCE+estremo_m*(CBCCCECF)+sqrt(deltaquartiP_bis)
				 xx(2)=dmin1(-CACBCDCE+estremo_m*(CBCCCECF)-sqrt(deltaquartiP_bis),-CACBCDCE+sqrt(deltaquartiP_bis))
				 xx(3)=dmax1(-CACBCDCE+estremo_m*(CBCCCECF)-sqrt(deltaquartiP_bis),-CACBCDCE+sqrt(deltaquartiP_bis))
				 xx(5)=xx(4)
				 xx(6)=xx(4)				 
             endif
         case(3)
		     xx(1)=dmin1((CFCACCCD-cp*delta_x)/(-CBCFCECC),(CFCACCCD+cp*delta_x)/(-CBCFCECC))
			 xx(6)=dmax1((CFCACCCD-cp*delta_x)/(-CBCFCECC),(CFCACCCD+cp*delta_x)/(-CBCFCECC))
			 if(deltaquartiP_bis.ge.0.d0)then
			     xx(2)=-(CACBCDCE)-sqrt(deltaquartiP_bis)
				 xx(3)=-(CACBCDCE)+sqrt(deltaquartiP_bis)
		     else		 
		     	 xx(2)=xx(1)
				 xx(3)=xx(1)
			 endif
			 if(deltaquartiP_bbis.ge.0.d0)then
			     xx(4)=-(CACBCDCE)+estremo_m*CBCCCECF-sqrt(deltaquartiP_bbis)
				 xx(5)=-(CACBCDCE)+estremo_m*CBCCCECF+sqrt(deltaquartiP_bbis)
		     else		 
		     	 xx(4)=xx(6)
				 xx(5)=xx(6)
			 endif
			 DO ii=2,6 !!!!!!!!!!!!!!!!ordinamento dei punti con insertion sort
                 app=xx(ii)       
                 jj=ii-1
                 do while (jj.ge.1)
                     if (xx(jj).gt.app) then
                         xx(jj+1)=xx(jj)
                         jj=jj-1 
                         xx(jj+1)=app
                     else 
                         exit
                     endif
	             enddo
             ENDDO
	 end select
	 do ii=1,6!!!!!!!!!!!!!!!!!taglio fuori i punti  minori di zero e maggiori di estremo_m_tilde
	     if(xx(ii).lt.0.d0)then
		     xx(ii)=0.d0
		 endif
         if(xx(ii).gt.estremo_m_tilde)then
		     xx(ii)=estremo_m_tilde
		 endif
	 enddo
        DO ii=1,5!!!!!!!!!!!!!!!!!!!!!!!!integrazione nucleo su EP!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!            
            if(xx(ii+1)-xx(ii).gt.1.d-14)then
                alfa_d=(xx(ii+1)-xx(ii))/2.d0
                beta_d=(xx(ii+1)+xx(ii))/2.d0
        
                iplog_d=1
                iqlog_d=1
                if(curva_piu_meno(beta,flag_extra,1,cp).le.estremo_m)then
                    iqlog_d=2
                elseif((curva_piu_meno(x(ii),flag_extra,1,cp).eq.estremo_m).or.(curva_piu_meno(x(ii+1),flag_extra,1,cp).eq.estremo_m))then
                    iqlog_d=2         
                endif			

                if(curva_piu_meno(beta,flag_extra,-1,cp).ge.0.d0)then
                    iplog_d=2
                elseif((curva_piu_meno(x(ii),flag_extra,-1,cp).eq.0.d0).or.(curva_piu_meno(x(ii+1),flag_extra,-1,cp).eq.0.d0))then
                    iplog_d=2
                endif
		 
                istat = cudaEventRecord(start,0) 
                call preCalculationEP<<<dimGrid,dimBlockPreCalculation>>>(alfa_d,beta_d,iplog_d, iqlog_d)                                
                call performCalcEP<<<dimGrid,dimBlockCalculation,sizeof(app)*NGaussDimension*NGaussDimension>>>(alfa_d,CalculationResults(5+ii,rowIndex))                
                !Vuextra_sub = Vuextra_sub + result

                ! istat = cudaEventRecord(stop,0)
                ! istat = cudaEventSynchronize ( stop )
                ! istat = cudaEventElapsedTime(time, start, stop)                
                ! gputime = gputime + time/(1.0e3)

                !ierrSync = cudaGetLastError()
                !if (ierrSync /= cudaSuccess) then
                !   write(*,*) 'Sync kernel error:', cudaGetErrorString(ierrSync)
                !endif            
            endif		 
        enddo	 
    
  endif  
RETURN

   CONTAINS 
   
   FUNCTION curva_piu_meno(x_linea,tipo_allineamento,segno,vel) !!! per definire le rette dei domini in caso di elementi allineati (o eventualmete limiti delle ordinate)
      REAL(kind=8) :: curva_piu_meno, x_linea, vel
      INTEGER(kind=4) :: tipo_allineamento, segno
	  select case (tipo_allineamento)
         case (1)!!!!!allineati
             curva_piu_meno=CBCCCECF*x_linea+CACCCFCD+sign(1,segno)*vel*delta_x
         case (2)!!!!!paralleli
             curva_piu_meno=CBCCCECF*x_linea+CACCCFCD+sign(1,segno)*sqrt(dabs((vel*delta_x)**2-(CFCACCCD)**2))
         case (3)!!!!!generici
             curva_piu_meno=CBCCCECF*x_linea+CACCCFCD+sign(1,segno)*sqrt(dabs(-(CBCFCECC*x_linea)**2+2*CBCFCECC*(-CFCACCCD)*x_linea-(CFCACCCD)**2+vel**2*delta_x**2))
      end select
   END FUNCTION curva_piu_meno
END